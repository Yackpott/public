Resumen IIC 2233 I2
===================


Nombre:  **Rodolfo Blanco**
Nro Alumno:  **14208369**

----------


Abstract Class
-------------

Las clases abstractas son clases cuyas instancias no tienen mucho sentido a menos que correspondan a alguna sub-clase específica. 

Funcionan así: si uno intenta instanciar de parte de una clase que tiene definido un abstractmethod(o abstractproperty) que no ha sido overrideado en una subclase, se levanta la excepción TypeError.

Tiene:
Metodos abstractos
Tienen que ser implementados en cada subclase
Metodos normales
Tienen que ser implementados en la clase abstracta

```
from abc import ABCMeta, abstractmethod, abstractproperty

class A(metaclass=ABCMeta):
    pass

a = A() # se instancia sin problemas

class Figura(metaclass=ABCMeta):
    @abstractmethod
    def trasladar(self):
        pass

    @abstractproperty
    def perimetro(self):
        pass

# TypeError: Can't instantiate abstract class
# with abstractmethods trasladar, perimetro
f = Figura()

class Cuadrado(Figura):
    pass

# Lanza la misma excepcion que arriba
c = Cuadrado()

class Triangulo(Figura):
    def __init__(self, lado, centro):
        self.lado = lado    # Los suponemos equilateros
        self.centro = centro

    def trasladar(self, nuevo):
        self.centro = nuevo

    @property
    def perimetro(self):
        return 3*self.lado

# Success!
t = Triangulo(4, (0, 0))
```


----------


Excepciones
-------------

Las excepciones corresponden a errores de ejecución o situaciones en las cuales el programa NO puede obtener un valor válido o esperado.
Tipos de excepciones:
SyntaxError
NameError
ZeroDivisionError
IndexError
TypeError
AttributeError
KeyError

```
class Operaciones:
    
    def dividir(num,den):
        try:
            if not (isinstance(num, int) and isinstance(den, int)):
                raise TypeError()

            if num < 0 or den < 0:
                raise Exception('Valores negativos')
            
            resultado = float(num)/float(den)
        
        except (ZeroDivisionError, TypeError):
            # Este bloque opera para los tipos de excepciones definidos
            print('Revise los datos de entrada, no son ints o bien el denominador es 0!')
        
        except Exception:
            # Este bloque solo maneja excepciones del tipo Except
            print('Los valores ingresados son negativos')
        
        else:
            # Como no hubo excepciones puede retornar normalmente el resultado
            # En este caso si se coloca el return después de la operación, 
            # si esta es correcta nunca llegará a este punto
            print('Todo OK!, no hay errores con los datos')
            return resultado
        
        finally:
            print('Recuerde SIEMPRE usar excepciones para manejar los errores de su programa\n')
            
o1 = Operaciones.dividir(10,0)
o2 = Operaciones.dividir(20,6)
print('resultado: {}'.format(o2))
```
Revise los datos de entrada, no son ints o bien el denominador es 0!
Recuerde SIEMPRE usar excepciones para manejar los errores de su programa

Todo OK!, no hay errores con los datos
Recuerde SIEMPRE usar excepciones para manejar los errores de su programa

resultado: 3.3333333333333335

```
class ErrorTransaccion(Exception):
    def __init__(self, fondos, gasto):
        super().__init__("El dinero en la billetera no alcanza para pagar ${}".format(gasto))
        self.fondos = fondos
        self.gasto = gasto
    
    def exceso(self):
        return self.fondos - self.gasto

class Billetera:
    def __init__(self, dinero):
        self.fondos = dinero
    
    def pagar(self, gasto):
        if self.fondos - gasto < 0:
            raise ErrorTransaccion(self.fondos, gasto)
        self.fondos -= gasto

if __name__ == '__main__':
    b = Billetera(1000)

    try:
        b.pagar(1500)
    except ErrorTransaccion as err:
        print('Error: {}. Hay un exceso de gastos de ${}.'.format(err, err.exceso()))
```
Error: El dinero en la billetera no alcanza para pagar \$1500. Hay un exceso de gastos de \$-500.


----------

Testing
-------------
Testing es el arte de generar código capaz de poner a prueba nuestros programas, chequeando que nuestro desarrollo pasa todas las pruebas en las cuales será sometido por los usuarios finales.

**Unittest:**
Por convención todos los métodos que implementamos para testear deben llamarse comenzando con la palabra "test".
```
class MostrarAsserts(unittest.TestCase):
    
    def test_aserciones(self):
        a = 2
        b = a
        c = 1. + 1.
        self.assertEqual([1,2,3], [1,2,3]) #falla si a != b
        self.assertNotEqual("hola", "chao") #falla si a == b
        self.assertTrue("Hola" == "Hola") #falla si bool(x) es False
        self.assertFalse("Hola" == "Chao") #falla si bool(x) es True
        self.assertIs(a, b) #falla si a no es b
        self.assertIsNot(a, c) #falla si a es b. Notar que "is" implica igualdad (==), pero no al revés, dos objetos distintos
                                #pueden tener el mismo valor
        self.assertIsNone(None) #falla si x no es None
        self.assertIsNotNone(2) #falla si x es None
        self.assertIn(2, [2,3,4]) #falla si a no está en b
        self.assertNotIn(1, [2,3,4]) #falla si a está en b
        self.assertIsInstance("Hola", str) #falla si isinstance(a, b) es False
        self.assertNotIsInstance("1", int) #falla si isinstance(a, b) es True
    
suite = unittest.TestLoader().loadTestsFromTestCase(MostrarAsserts)
unittest.TextTestRunner().run(suite)
```
```
def average(seq):
    return sum(seq) / len(seq)
class TestAverage(unittest.TestCase):
    def test_python30_zero(self):
        self.assertRaises(ZeroDivisionError, average,[])
        
    def test_python31_zero(self):
        with self.assertRaises(ZeroDivisionError):
            average([])

suite = unittest.TestLoader().loadTestsFromTestCase(TestAverage)
unittest.TextTestRunner().run(suite)
```

Más test:

```
assertAlmostEqual(first, second, places=7, msg=None, delta=None)
assertNotAlmostEqual(first, second, places=7, msg=None, delta=None)
assertGreater(first, second, msg=None)#msg es el mensaje que se generará en la aserción
assertGreaterEqual(first, second, msg=None)
assertLess(first, second, msg=None)
assertLessEqual(first, second, msg=None)
```

**El metodo setUp:**
El método setUp nos permite declarar las variables que serán usadas para los tests, además se preocupa de volver a setear o inicializar las variables antes de entrar a un test nuevo, en caso de que uno de los otros tests tuvo que modificar algo en las variables.

```
class TestearEstadisticas(unittest.TestCase):
    
    def setUp(self):
        self.stats = ListaEstadisticas([1,2,2,3,3,4])
        
    def test_media(self):
        print(self.stats)
        self.assertEqual(self.stats.media(), 2.5)
        
    def test_mediana(self):
        self.assertEqual(self.stats.mediana(), 2.5)
        self.stats.append(4)
        self.assertEqual(self.stats.mediana(), 3)
        
    def test_moda(self):
        print(self.stats)
        self.assertEqual(self.stats.moda(), [2,3])
        self.stats.remove(2)
        self.assertEqual(self.stats.moda(), [3])
                
suite = unittest.TestLoader().loadTestsFromTestCase(TestearEstadisticas)
unittest.TextTestRunner().run(suite)
```

**El metodo tearDown:**
Además del método setUp, TestCase nos ofrece el método tearDown, que puede ser usado para "limpiar" después de que terminaron de ejecutarse todos los tests. Por ejemplo, si nuestros tests tienen la necesidad de crear algunos archivos, la idea es que al final todos esos archivos temporales sean eliminados, de tal forma de asegurar que el sistema está en el mismo estado en que estaba antes de ejecutar los tests.

```
import os

class TestearArchivo(unittest.TestCase):
    
    def setUp(self):
        self.archivo = open("prueba.txt",'w')
        self.diccionario = {1 : "Hola", 2 : "Chao" }

    def tearDown(self):
        self.archivo.close()
        print("Eliminando archivos temporales...")
        os.remove("prueba.txt")
        
    def test_str(self):
        print("escribiendo archivo temporal...")
        self.archivo.write(self.diccionario[1])
        self.archivo.close()
        self.archivo = open("prueba.txt",'r')
        d = self.archivo.readlines()[0]
        print(d)
        self.assertEqual(self.diccionario[1], d)
                        
suite = unittest.TestLoader().loadTestsFromTestCase(TestearArchivo)
unittest.TextTestRunner().run(suite)
```

**El modulo Discover:**

```
class TestAritmetico(unittest.TestCase):

    def test_arit(self):
        self.assertEqual(1+1==2)

def suite():
    suite = unittest.TestSuite()
    suite.addTest(TestAritmetico())
    return suite

Tsuite = unittest.TestLoader().loadTestsFromModule(suite())#ojo, FromModule en vez de FromTestCase
unittest.TextTestRunner().run(Tsuite)
``` 

**Ignorar test:**
La "x" en la primera línea significa "falla esperada" (expected failure), la "s" significa "test ignorado" (skipped test), la "F" significa una falla real (real failure).
```
import unittest
import sys

class IgnorarTests(unittest.TestCase):
    
    @unittest.expectedFailure
    def test_falla(self):
        self.assertEqual(False, True)
        
    @unittest.skip("Test inútil")
    def test_ignorar(self):
        self.assertEqual(False, True)
        
    @unittest.skipIf(sys.version_info.minor == 1, "no funciona en 3.1")
    def test_ignorar_if(self):
        self.assertEqual(False, True)
        
    @unittest.skipUnless(sys.platform.startswith('linux'), "no funciona en linux")
    def test_ignorar_unless(self):
        self.assertEqual(False, True)
suite = unittest.TestLoader().loadTestsFromTestCase(IgnorarTests)
unittest.TextTestRunner().run(suite)
```

**py.test:**
Cuando ejecutamos py.test, comienza en la carpeta actual buscando todos los módulos o subpaquetes que comienzan con "test_". Cualquier función en ese módulo que también comience con "test_" será ejecutada como un test individual. Si existe alguna clase (dentro del módulo) que comienza con "Test", cualquier método dentro de esa clase que comience con "test_" también será ejecutado en el ambiente de testeo.

```
def test_int_float():
    assert 1 == 1.0
def test_int_str():
    assert 1 == "1"
```
```
class TestNumbers:
       def test_int_float(self):
           assert 1 == 1.0
       def test_int_str(self):
           assert 1 == "1"
```


**Setup y Teardown en pytest:**
La principal diferencia entre los métodos setup y teardown de pytest (más precisamente "setup_method" y "teardown_method" en pytest) con los de unittest, es que en pytest estos métodos aceptan un argumento: la función (objeto) que representa el método que se está llamando.
Además pytest provee las funciones de setup_class y teardown_class que son métodos que deben testear una clase, reciben como argumento la clase que van a testear.
Finalmente, los métodos setup_module y teardown_module son métodos que corren antes y después de todos los tests (ya sean de funciones o clases) en el módulo. El siguiente ejemplo muestra cómo usar cada uno de estos métodos y en qué orden se van ejecutando:

```
def setup_module(module):
       print("setting up módulo {0}".format(module.__name__))
        
def teardown_module(module):
       print("tearing down módulo {0}".format(module.__name__))
        
def test_a_function():
       print("Ejecutando función de test")

class BaseTest:
    
    def setup_class(cls):
        print("setting up Clase {0}".format(cls.__name__))
        
    def teardown_class(cls):
        print("tearing down Clase {0}\n".format(cls.__name__))
        
    def setup_method(self, method):
        print("setting up método {0}".format(method.__name__))
        
    def teardown_method(self, method):
        print("tearing down  método {0}".format(method.__name__))
        
class TestClass1(BaseTest):
    
    def test_method_1(self):
        print("Ejecutando Método 1-1")
        
    def test_method_2(self):
        print("Ejecutando Método 2-1")
        
class TestClass2(BaseTest):
    
    def test_method_1(self):
        print("Ejecutando Método 1-2")
        
    def test_method_2(self):
        print("Ejecutando Método 2-2")
```

**Funcargs en py.test:**
```
def pytest_funcarg__valid_stats(request):
    return ListaEstadisticas([1,2,2,3,3,4])
    
def test_mean(valid_stats):
    assert valid_stats.mean() == 2.5
    
def test_median(valid_stats):
    assert valid_stats.median() == 2.5
    valid_stats.append(4)
    assert valid_stats.median() == 3
        
def test_mode(valid_stats):
    assert valid_stats.mode() == [2,3]
    valid_stats.remove(2)
    assert valid_stats.mode() == [3]
```

**El metodo request.addfinalizer:**

```
import tempfile
import shutil
import os.path

def pytest_funcarg__temp_dir(request):
    dir = tempfile.mkdtemp()
    print(dir)
    def cleanup():
        shutil.rmtree(dir)

    request.addfinalizer(cleanup)
    return dir


def test_osfiles(temp_dir):
    os.mkdir(os.path.join(temp_dir, 'a'))
    os.mkdir(os.path.join(temp_dir, 'b'))
    dir_contents = os.listdir(temp_dir)
    assert len(dir_contents) == 2
    assert 'a' in dir_contents
    assert 'b' in dir_contents
```

**Ignorar test en py.test:**
```
import sys
import py.test

def test_simple_skip():
    if sys.platform != "Linows":
        py.test.skip("El Test sólo funciona en OS Linows")
    fakeos.do_something_fake()
    assert fakeos.did_not_happen
```
```
import sys
import py.test

@py.test.mark.skipif("sys.platform != \"Linows\"")
def test_simple_skip():
    fakeos.do_something_fake()
    assert fakeos.did_not_happen
```

----------


Threads
-------------

```
import threading
import time

def worker(tiempo):
    print("{} starting...".format(threading.currentThread().getName()))
    time.sleep(tiempo) # pone a dormir el thread por t segundos simulando que ocurre algun proceso dentro de la función
    print("{} exiting...".format(threading.currentThread().getName()))

    
# Se crean los threads usando la clase Thread, asociada a la función objetivo para 
# ser ejecutada por el thread, y los atributos de la función son ingresados mediante la llave args. 
# En este ejemplo, args tiene asignado una tupla de un solo elemento. Por tal razón
# debe ser escrita como (valor,)

w = threading.Thread(name='Thread 2', target=worker, args=(3,))
w.start()
w.join()
```

```
import threading
import time

class Worker(threading.Thread):
    def __init__(self):
        super().__init__()
    
    def run(self):
        print("{} starting...".format(threading.currentThread().getName()))
        time.sleep(2) # pone a dormir el thread por t segundos simulando que ocurre algun proceso dentro de la función
        print("{} exiting...".format(threading.currentThread().getName()))

class Service(threading.Thread):
    def __init__(self):
        super().__init__()
    
    def run(self):
        print("{} starting...".format(threading.currentThread().getName()))
        time.sleep(4) # pone a dormir el thread por 4 segundos simulando un proceso dentro de la función
        print("{} exiting...".format(threading.currentThread().getName()))
        

# Se crean los threads usando la clase Thread
t1 = Service()
w1 = Worker()
w2 = Worker()

# Se inicializan los threads creados
w1.start()
w2.start()
t1.start()

# Todas estas líneas serán ejecutadas mientras los threads se ejecutan independientemente del programa principal.
print('Fueron creados 3 threads')

for i in range(10):
    print(i)
```
**Join():**
Si necesitamos que el programa principal espere que termine la ejecución de algún thread o grupo de threads debemos usar del método join(< tiempo-máximo-espera >) después de que el thread ha sido iniciado mediante start(). Al usar join() el programa principal queda bloqueado hasta que los threads referenciados terminen correctamente. Si el tiempo máximo de espera no ha sido definido, el programa principal esperará indefinidamente hasta que el thread referenciado termine.

```
import threading
import time

def worker():
    print("{} starting...".format(threading.currentThread().getName()))
    time.sleep(2) # pone a dormir el thread por t segundos simulando que ocurre algun proceso dentro de la función
    print("{} exiting...".format(threading.currentThread().getName()))

def service():
    print("{} starting...".format(threading.currentThread().getName()))
    time.sleep(4) # pone a dormir el thread por 4 segundos simulando un proceso dentro de la función
    print("{} exiting...".format(threading.currentThread().getName()))


# Se crean los threads usando la clase Thread
t1 = threading.Thread(name='Thread 1', target=service)
w1 = threading.Thread(name='Thread 2', target=worker)
w2 = threading.Thread(target=worker) # En este caso usa el nombre asignado por defecto

# Se inicializan los threads creados
w1.start()
w2.start()
t1.start()

# Aquí incorporamos el método join() para bloquear el programa principa
w1.join()
w2.join()
t1.join()

# Una vez que los threads son creados el programa principal sigue su curso y espera 
# a que los threads terminen. Por ejemplo, todas estas líneas serán ejecutadas después 
# que los threads sean ejecutados, pero el programa principal no se cerrará hasta que 
# los threas hayan completado su ejecución.
print('Fueron creados 3 threads')

for i in range(10):
    print(i)
```
**IsAlive():**
Es posible identificar si un thread ha terminado su ejecución mediante el uso del método IsAlive(). Por lo general este método se implementa para saber el estado del thread después del uso de join() al cual se le ha definido su tiempo máximo de espera.

```
import threading
import time


# Se crean los threads usando la clase Thread
t = threading.Thread(target=service)

# Se inicializan el threads
t.start()
t.join(5) # el programa esperará por 5 segundos a que el thread termine

# Podemos comprobar si el thread terminó
if not t.isAlive():
    print('El thread ha terminado correctamente')
```

**Daemons:**
Los "daemon threads" son los que a pesar de que estén aún corriendo, no impiden que el programa principal termine. Se puede usar join() para esperarlos si es que fuera necesario.

```
import threading
import time

def worker():
    print("{} starting...".format(threading.currentThread().getName()))
    time.sleep(2) # pone a dormir el thread por t segundos simulando que ocurre algun proceso dentro de la función
    print("{} exiting...".format(threading.currentThread().getName()))

def service():
    print("{} starting...".format(threading.currentThread().getName()))
    time.sleep(4) # pone a dormir el thread por 4 segundos simulando un proceso dentro de la función
    print("{} exiting...".format(threading.currentThread().getName()))

# Se crean los threads usando la clase Thread
t1 = threading.Thread(name='Thread 1', target=service)
w1 = threading.Thread(name='Thread 2', target=worker)

# Se configuran los threads como Daemon
w1.setDaemon(True)
t1.setDaemon(True)

# Se inicializan los threads
w1.start()
t1.start()
```
**Timers:**
La clase Timer es una subclase de la clase Thread y permite ejecutar un proceso o acción después que ha pasado un determinado tiempo. Timer requiere como parámetros básicos el tiempo en segundos después del cual debe ejecutarse el thread, el nombre del proceso a ejecutar y los argumentos de entrada para el proceso. El método cancel() permite, si se requiere, cancelar la ejecución del timer antes que este sea ejecuctado.

```
def mi_timer(archivo):
    with open(archivo) as fid:
        for linea in fid:
            print(linea)
    fid.close()


# Los archivos para probar están junto con la materia
t1 = threading.Timer(10.0, mi_timer, args=('mensaje_01.txt',))
t2 = threading.Timer(5.0, mi_timer, args=('mensaje_02.txt',))

t1.start() # el thread t comenzará después de 10 seconds
t2.start() # el thread t comenzará después de 5 seconds
```

**Bloqueo:**
El bloqueo permite la sincronización para el acceso a los recursos compartidos entre dos o más threads. La librería Threading nos provee de la clase Lock que permite esta sincronización. Un bloqueo tiene dos estados: bloqueado y desbloqueado. El estado por defecto es desbloqueado. Para bloquear la ejecución de otros threads durante su ejecución se utiliza el método acquiere() mediante el cual el thread actual que llega hasta ese punto del programa toma control del recurso. Durante este tiempo el resto de los threads detiene la ejecución cuando trata de tomar control del recurso hasta que se libera el acceso mediante el método release() llamado desde el thread que mantiene el bloqueo. En la siguiente figura vemos un esquema general de sincronización entre threads usan bloqueos.

```
import threading


class MiThread(threading.Thread):
    # Esta clase modela un thread. Dentro creamos un objeto para bloqueo dentro de la clase
    lock = threading.Lock()
    
    def __init__(self, i, archivo):
        super().__init__()
        self.i = i
        self.archivo = archivo
    
    def run(self):
        # El método run() maneja que debe hacer el thread durante la ejecución 
        # cada vez que se llama al método start()
        
        MiThread.lock.acquire() # bloquea la ejecución de los demas threads al intentar escribir en el archivo
        try:
            self.archivo.write('Esta linea fue escrita por el thread # {}\n'.format(self.i))
        finally:
            MiThread.lock.release() # devuelve el control del recurso a los threads en espera
            
                
if __name__ == '__main__':
    num_threads = 15
    threads = []
    
    # Creamos un archivo para escribir una salida. Luego creamos los threads 
    # que escribirán dentro del archivo
    
    with open('salida.txt', 'w') as archivo:
        for i in range(num_threads):
            my_thread = MiThread(i, archivo) # se crea el thread pasando sus parámetros
            my_thread.start() # Se inicializa el thread. Se ejecuta lo que tiene el método run()
            threads.append(my_thread)
```
```
def run(self):
    with MiThread.lock:
        self.archivo.write('Esta linea fue escrita por el thread # {}\n'.format(self.i))
```

**Cola segura:**

```
import collections

class MiDeque(collections.deque):
    # Para crear la cola heredamos un deque desde el modulo collections 
    # y agregaremos los mecanismos de bloqueo para asegurar la sincronización 
    # entre los threads.

    def __init__(self):
        super().__init__()
        self.lock = threading.Lock() # agregamos el seguro a la cola

    def agregar(self, elemento):
        # Como mencionamos anteriormente, los bloqueos pueden ser usados
        # dentro de un context-manager

        with self.lock:
            self.append(elemento)
            print('[AGREAGAR] cola tiene {} elementos'.format(len(self)))

    def obtener(self):
        with self.lock:
            print('[SACAR] la cola tiene {} elementos'.format(len(self)))
            return self.popleft()
```
**Productor-Consumidor:**
```
import threading
import time


class Productor(threading.Thread):
    def __init__(self, cola):
        super().__init__()
        self.cola = cola

    def run(self):
        # Abrimos un contexto para manejar el archivo de entrada y procesamos cada línea

        with open('lista_numeros.txt') as archivo:           
            for linea in archivo:
                valores = tuple(map(int, linea.strip().split(',')))
                self.cola.agregar(valores)


def consumidor(cola):
    # Recordar que los threads pueden ser implementados tanto como objetos, como por funciones.

    with open('numeros_procesados.txt', 'w') as archivo:
        while len(cola) > 0:
            numeros = cola.obtener()
            archivo.write('{}\n'.format(sum(numeros)))
            time.sleep(0.001) # ayuda a simular que el consumidor es más lento que el productor
            


if __name__ == '__main__':

    cola = MiDeque()

    p = Productor(cola)
    p.start()
    
    c = threading.Thread(target=consumidor, args=(cola,))
    c.start()
```

**Queue:**
Los métodos principales de una cola de la librería Queue son:
put(): agrega un ítem a la cola (push)
get(): remueve y retorna un ítem desde la cola (pop)
task_done(): require ser llamado cada vez que in ítem ha sido procesado
join(): bloquea la cola hasta que todos los ítems han sido procesados

```
import threading
import time
import queue

class Productor(threading.Thread):
    def __init__(self, cola):
        super().__init__()
        self.cola = cola

    def run(self):
        with open('lista_numeros.txt') as archivo:
            for linea in archivo:
                valores = tuple(map(int, linea.strip().split(',')))
                self.cola.put(valores)
                print('[Productor] la cola tiene {} elementos'.format(self.cola.qsize()))
                time.sleep(0.001) # ayuda a simular que los procesos son más pesados computacionalmente

def consumidor(cola):
    with open('numeros_procesados.txt', 'w') as archivo:
        while True:
            # Se utiliza try/except para detener el consumidor una vez que no queden más elementos
            # en la cola. De no usar esta estructura el consumidor estaría ejecutándose infinitamente

            try:
                numeros = cola.get(False) # si no hay más elementos en la cola levanta una excepcion del tipo Empty
            except queue.Empty:
                break
            else:
                archivo.write('{}\n'.format(sum(numeros)))
                cola.task_done()

                # qsize() retorna el tamaño de la cola
                print('[Consumidor] la cola ahora tiene {} elementos'.format(cola.qsize())) 
                
                # Simula un proceso más pesado. Ayuda a sincronizar ambos threads. 
                # Puede ser que el consumidor sea más rápido que el productor originando
                # que los threads terminen abruptamente.

                time.sleep(0.005)


if __name__ == '__main__':

    Q = queue.Queue() # se crea una cola sincronizada desde la librería queue

    p = Productor(Q) # se crea el productor que recibe como argumento una cola Q
    p.start()

    c = threading.Thread(target=consumidor, args=(Q,)) # se crea un thread con el consumidor. También recibe la cola
    c.start()
```

----------


Simulación:
-------------
a simulación consiste en el proceso mediante el cual se modela un sistema y se realizan experimentos sobre el modelo diseñado. El objetivo principal es comprender el comportamiento del sistema o evaluar el funcionamiento del modelo.

**Componentes de un Modelo de Simulación:**
Un modelo de simulación se compone de los siguientes elementos:
Un conjunto de variables de estado que describen el sistema en cualquier instante determinado. Estas variables deben ser inicializadas antes de comenzar la simulación. Dentro de las variable de estado deben existir:
un reloj que almacena el tiempo real del modelo de simulación.
un arreglo que almacene el siguiente tiempo de ocurrencia de cada evento posible.
Una cola de eventos ordenada temporalmente que determina cómo los eventos irán ocurriendo durante la simulación. Se asume que entre dos eventos consecutivos no existe otro evento que cambie el sistema.
Cada tipo de evento tendrá su propia subrutina que manejará la actualización del reloj y de las variables de estado correspondientes.
Una rutina principal (main) que controla el suceso de los eventos y el paso de control entre la subrutina que se debe seguir en cada caso.
Variables de desempeño (estadísticas) y monitores que nos permitan obtener sus valores.

**Simulación Síncrona:**

El algoritmo general de este tipo de simulación es:
MIENTRAS el tiempo simulación no termine
    aumentar tiempo en una unidad
    si ocurren eventos en este intervalo de tiempo:
        simular los eventos

Considerando que en general las simulaciones requieren de mucho tiempo para ejecutarse y producir resultados, la simulación síncrona presenta las siguientes desventajas:
La ejecución es muy lenta
La mayoría de los incrementos no producirá cambios en el estado del sistema
Las actividades de verificación generan una pérdida importante del tiempo de CPU.

**Simulación basada en Eventos Discretos (DES):**
El algoritmo general de una simulación basa en eventos discretos es el siguiente:
MIENTRAS la lista de eventos no esté vacía y el tiempo de simulación no termine
    tomar un evento desde el principio de la lista de eventos
    avanzar el tiempo de simulación al tiempo del evento
    simular el evento

**Simpy:**

```
import simpy
import random

def mesero(env, cocina):
    yield env.timeout(5)      # el tiempo en el cual se interrumpirá la preparación
    cocina.accion.interrupt()  # usamos el método interrupt() del proceso cocina

class Cocina:
    
    def __init__(self, env):
        self.env = env    # referenciamos el environment
        self.accion = env.process(self.run())  # asociamos el proceso para cada instancia
        
    def run(self):
        while True:
            print('Comineza praparacion del plato t={0}'.format(self.env.now))
            
            # Modelaremos que el proceso debe esperar por la preparación del plato
            # Generamos un nuevo evento que espera por la preparación
            try:
                yield self.env.process(self.preparacion())
                
            except simpy.Interrupt:
                # Si la preparación del plato demora más del tiempo permitido
                # debe interrumpirse y ser pasado a cocción
                print('[MESERO] la preparación demora mucho, llevar al horno tal como esté')
            
            # La cocción de los platos tendrá un tiempo variable entre 5 y 10 min
            print('Plato al horno en t={0}'.format(self.env.now))
            duracion_coccion = random.randint(5, 10)
            yield self.env.timeout(duracion_coccion)

    def preparacion(self):
        # La preparación de cada plato dura entre 5 y 20 min
        yield self.env.timeout(random.randint(5, 20))
        

# En este ejemplo ejecutaremos la simulación hasta el tiempo_maximo
tiempo_maximo = 100

env = simpy.Environment()     # creamos un ambiente para simular
cocina = Cocina(env)          # agregamos al ambiente un proceso
env.process(mesero(env, cocina))
env.run(until=tiempo_maximo)  # ejecutamos la simulacion hasta el tiempo máximo
```

**Resources:**

```
import simpy
import random

class Clientes:
    def __init__(self, env, resource):
        self.env = env
        self.resource = resource
        self.accion = self.env.process(self.run())
        self.ultimo_tiempo = 0
        
    def run(self):
        while True:
            # Genera un evento de solicitud
            solicitud = self.resource.request()
            
            # Esperamos por el acceso al recurso
            yield solicitud
            
            # Generamos el tiempo de ejecución para la tarea
            self.ultimo_tiempo = self.env.now
            yield self.env.timeout(random.randint(5,10))            
            print('Recurso usado en {} tiempo durante {} minutos'.\
                  format(self.env.now, self.env.now - self.ultimo_tiempo))
            
            # Liberamos el recurso
            self.resource.release(solicitud)     

            
# Creamos una simulación que se ejecutará hasta que no haya elementos en la cola

env = simpy.Environment()                # creamos el ambiente de simulación
res = simpy.Resource(env, capacity=1)    # creamos un recurso con capacidad de 1 proceso
c = Clientes(env, res)                    # agregamos un primer cliente a la cola
env.run(until=40)                        # ejecutamos la simulación
```
**Priority Resources:**

```
import simpy
import random

class Cliente:
    def __init__(self, c_id, env, resource, tiempo_espera, prioridad):
        self.env = env
        self.resource = resource
        
        self.cliente_id = c_id
        self.tiempo_espera = tiempo_espera
        self.prioridad = prioridad
        self.accion = self.env.process(self.run())
    
    def run(self):
        # En este caso sin usar while el cliente queda como una entidad única
        yield self.env.timeout(self.tiempo_espera)

        with self.resource.request(priority=self.prioridad) as req:
            print('cliente {} solicitando recursos en tiempo={}. Prioridad={}.'.\
                  format(self.cliente_id, self.env.now, self.prioridad))
            yield req
            print('cliente {} obtiene recurso en tiempo={}'.format(self.cliente_id, self.env.now))
            yield self.env.timeout(3)
            
env = simpy.Environment()
res = simpy.PriorityResource(env, capacity=1)
c1 = Cliente(1, env, res, tiempo_espera=0, prioridad=0)
c2 = Cliente(2, env, res, tiempo_espera=1, prioridad=0)
c3 = Cliente(3, env, res, tiempo_espera=2, prioridad=-1)
env.run()
```

**Containers:**

```
import simpy
import random


class Bodega:
    
    def __init__(self, env):
        self.env = env
        self.vendedores = simpy.Resource(self.env, capacity=2)
        self.stock = simpy.Container(self.env, init=100, capacity=1000)
        self.process = env.process(self.monitor_bodega())
    
    def monitor_bodega(self):
        while True:
            if self.stock.level < 100:
                print('Pedir suministros en {0}'.format(self.env.now))
                self.env.process(camion(self.env, self))
                
            yield self.env.timeout(random.uniform(1,15))
            

def camion(env, bodega):
    yield env.timeout(random.uniform(1,10)) # tiempo llegada
    print('Camion llega en {0}'.format(env.now))
    cantidad = bodega.stock.capacity - bodega.stock.level # el camión suministra lo que falta para llenar la bodega
    yield bodega.stock.put(cantidad)
    print('Camion suminista {0} articulos'.format(cantidad))
    

def cliente(ids, env, bodega):
    print('Cliente {0} llegando en {1}'.format(ids, env.now))
    with bodega.vendedores.request() as req:
        yield req
        cantidad = 40
        print('Cliente {0} compra {1} artículos en {2}'.format(ids, cantidad, env.now))
        yield bodega.stock.get(cantidad)
        yield env.timeout(random.uniform(1,5))
        print('Cliente {0} termina compra en {1}'.format(ids, env.now))
        
        
def generador_clientes(env, bodega):
    for i in range(4):
        env.process(cliente(i, env, bodega))
        yield env.timeout(random.uniform(1,5))

env = simpy.Environment()
bodega = Bodega(env)
car_gen = env.process(generador_clientes(env, bodega))
env.run(until=200)
```

Store y FilterStore

```
import simpy

def productor(env, store):
    for i in range(100):
        yield env.timeout(2)
        yield store.put('produccion {0}'.format(i))
        print('entrega productos en {0}'.format(env.now))


def consumidor(name, env, store):
    while True:
        yield env.timeout(1)
        print(name, 'solicitando producto en', env.now)
        item = yield store.get()
        print(name, 'entregado', item, 'en ', env.now)

env = simpy.Environment()
tienda = simpy.Store(env, capacity=2)

prod = env.process(productor(env, tienda))
comsumidores = [env.process(consumidor(i, env, tienda)) for i in range(2)]

env.run(until=5)
```

```
import simpy

NUM_AUTOS = 50

class Auto:
    marcas = ["Chevrolet", "Suzuki", "Mazda", "Subaru"]
    def __init__(self, marca):
        self.marca = marca

        
def productor(env, store):
    for i in range(NUM_AUTOS):
        yield env.timeout(1)
        auto = Auto(random.choice(Auto.marcas))
        yield store.put(auto)
        print('auto {0} agregado en {1}'.format(auto.marca, env.now))


def consumidor(name, env, store):
    while True:
        yield env.timeout(5)
        print(name, 'solicitando producto en', env.now)
        item = yield store.get(lambda auto: auto.marca == "Mazda")
        print('{} entregado a consumidor un auto {} en {}'.format(name, item.marca, env.now))

env = simpy.Environment()
tienda = simpy.FilterStore(env, capacity=NUM_AUTOS)

prod = env.process(productor(env, tienda))
comsumidores = [env.process(consumidor(i, env, tienda)) for i in range(10)]

env.run(until=2500)
```

----------


PyQt
-------------
```
from PyQt4 import QtGui, QtCore


class MiFormulario(QtGui.QWidget):
    def __init__(self):
        super().__init__()
        self.init_GUI()

def init_GUI(self):
        # Este método inicializa la interfaz y sus elementos
        self.label1 = QtGui.QLabel('Texto:', self)
        self.label1.move(10, 15)

        self.label2 = QtGui.QLabel('Aqui se escribe la respuesta', self)
        self.label2.move(10, 50)

        self.label3 = QtGui.QLabel('Origen de la señal:', self)
        self.label3.move(10, 250)

        self.edit1 = QtGui.QLineEdit('', self)
        self.edit1.setGeometry(45, 15, 100, 20)

        self.boton1 = QtGui.QPushButton('&Procesar', self)
        self.boton1.resize(self.boton1.sizeHint())
        self.boton1.move(5, 70)
        self.boton1.clicked.connect(self.boton1_callback)
        self.boton1.clicked.connect(self.boton_presionado)

        self.boton2 = QtGui.QPushButton('&Salir', self)
        self.boton2.clicked.connect(QtCore.QCoreApplication.instance().quit)
        self.boton2.resize(self.boton2.sizeHint())
        self.boton2.move(90, 70)

        # Agregamos todos los elementos al formulario
        self.setGeometry(200, 100, 300, 300)
        self.setWindowTitle('Ventana con Boton')
        self.show()

    def boton_presionado(self):
        # Esta función registra el objeto que envía la señal del evento y lo refleja 
        # mediante el método sender() en label3
        sender = self.sender()
        self.label3.setText('Señal de: {0}'.format(sender.text()))
        self.label3.resize(self.label3.sizeHint())

    def boton1_callback(self):
        self.label2.setText(self.edit1.text())

if __name__ == '__main__':
    app = QtGui.QApplication([])

    # Se crea una ventana descendiente de QMainWindows
    form = MiFormulario()
    form.show()
    app.exec_()
```

----------


IO
-------------

```
caracteres = b'\x63\x6c\x69\x63\x68\xe9' #aquí estamos diciendo que lo que está entre las comillas es un objeto de bytes                                         
print(caracteres) 
print(caracteres.decode("latin-1"))
caracteres = b"ab"
caracteres = b"\x61\x62"#61 y 62 es la representación en hexadecimal de a y b respectivamente
print(caracteres.decode("ascii"))
caracteres = bytes((97,98))#97 y 98 corresponden al código ascii de los caracteres a y b repectivamente
print(caracteres)
```

```
print(characters.encode("ascii", errors = 'replace'))#en ascii se reemplaza el caracter desconocido con "?"
print(characters.encode("ascii", errors = 'ignore'))
print(characters.encode("ascii", errors = 'xmlcharrefreplace'))#se crea una entidad xml que representa el caracter Unicode
```

```
ba_1 = bytearray(b"holamundo")
print(ba_1)
print(ba_1[3:7])
ba_1[4:6] = b"\x15\xa3"
print(ba_1)
ba_1.extend(b"programa")
print(ba_1)
print(ba_1[0])#Notar que aquí se imprime un entero, el ascii que corresponde a la letra "h"
print(bin(ba_1[0]))
print(bin(ba_1[0])[2:].zfill(8))
```

bytearray(b'holamundo')
bytearray(b'amun')
bytearray(b'hola\x15\xa3ndo')
bytearray(b'hola\x15\xa3ndoprograma')
104
0b1101000
01101000

```
print(ord(b"a"))
b = bytearray(b'abcdef')
b[3] = ord(b'g') #la letra g tiene como código ascii el 103
b[4] = 68 #la letra D tiene como código ascii el 68, esto sería lo mismo que ingresar b[4] = ord(b'D')
print(b)
```
bytearray(b'holamundo')
bytearray(b'amun')
bytearray(b'hola\x15\xa3ndo')
bytearray(b'hola\x15\xa3ndoprograma')
104
0b1101000
01101000

```
print(ord(b"a"))
b = bytearray(b'abcdef')
b[3] = ord(b'g') #la letra g tiene como código ascii el 103
b[4] = 68 #la letra D tiene como código ascii el 68, esto sería lo mismo que ingresar b[4] = ord(b'D')
print(b)
```
97
bytearray(b'abcgDf')

```
import string, random

class StringUpper(list): 
        
    def __enter__(self):
        return self
    
    def __exit__(self, type, value, tb):
        for i in range(len(self)):
            self[i] = self[i].upper()
        

with StringUpper() as s_upper:
    for i in range(20):
        s_upper.append(random.choice(string.ascii_lowercase))#aquí se va seleccionando en forma aleatoria un ascii en minúsculas
    print(s_upper)
        
print(s_upper)
```

**Cómo emular archivos para I/O:**
```
from io import StringIO, BytesIO
file_in = StringIO("información como texto y más")#aquí simulamos tener un archivo que contiene el string dado 
file_out = BytesIO()#aquí simulamos un archivo de Bytes para escribir la información

char = file_in.read(1)
while char:
    file_out.write(char.encode("ascii", "ignore"))
    char = file_in.read(1)
    
buffer_ = file_out.getvalue()
print(buffer_)
```

**Pickle:**

```
lista = [1,2,3,7,8,3]
with open("mi_lista", 'wb') as file:
    pickle.dump(lista, file)

with open("mi_lista", 'rb') as file:
    mi_lista = pickle.load(file)
    assert mi_lista == lista #estoy generaría un error si el objeto que cargamos no es igual al que guardamos
```

```
class Persona:
    
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad
        self.mensaje = "No pasa nada"
        
    def __getstate__(self):
        nueva = self.__dict__.copy()
        nueva.update({"mensaje" : "Me están serializando!!"})
        return nueva #esto es lo que será serializado por pickle

    def __setstate__(self, state):
        print("Objeto recién des-serializado, seteando su estado...\n")
        state.update({"nombre" : state["nombre"] + " deserializado"})
        self.__dict__ = state
    
m = Persona("Juan", 30)
print(m.nombre)
serial = pickle.dumps(m)
m2 = pickle.loads(serial)
print(m2.nombre)
```

**JSON:**

```
import json


class Vehiculo:

    def __init__(self, patente, marca, capacidad, ruedas):
        self.patente = patente
        self.marca = marca
        self.capacidad = capacidad
        self.ruedas = ruedas

    @classmethod
    def by_json(cls, atributos):
        return cls(**atributos)


v = Vehiculo('BB-NN-47', 'FasterFaster', 5, 3)
print(v.__dict__)

vSerializado = json.dumps(v.__dict__)

vDeserializado = json.loads(vSerializado)

vClon = Vehiculo.by_json(vDeserializado)

print(vClon)

print(vClon.__dict__)
```

----------


Networking
-------------

**Cliente TCP:**

```
import socket
import sys

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)#esto crea un socket para una conexión TCP con IPv4

try:
    s.connect(("www.python.org",80))        # nos conectamos con la dirección especificada
    s.send("GET /index.html HTTP/1.0\n\n\n".encode('ascii'))  # enviamos un string (codificado en bytes) pidiendo el contenido de index.html
    data = s.recv(1024)                    # recibimos la respuesta, el argumento indica el tamaño del bufer en bytes
    print(data.decode('ascii'))                    # aquí imprimimos los datos que recibimos después de codificarlos

    
except socket.error:
    print("No fue posible conectarse")
    sys.exit()

finally:
    s.close()# cerramos la conexión    
```

**Servidor TCP:**

```
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)#esto crea un socket para una conexión TCP con IPv4
host = socket.gethostname()                           
port = 10001
s.bind((host,port))     # este método "enlaza" el socket a un puerto dado, en este caso el puerto 80
s.listen(5)             #aquí le pedimos al sistema operativo que empiece a escuchar por potenciales conexiones al socket, el argumento 
                        #corresponde al número máximo de conexiones pendientes permitidas

cont = 0
while True:
    #aquí establecemos la conexión
    socket_cliente, address = s.accept()      
    print("Obtuvimos una conexión desde %s" % str(address))
    socket_cliente.send("{}. Hola nuevo amigo!\n".format(cont).encode("ascii"))
    socket_cliente.close()
    cont += 1
```

**Cliente UDP:**

```
import socket
MAXSIZE = 2048
#server_name = "127.0.0.1"
server_name = socket.gethostname()
server_port = 15000

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
mensaje = "Hola, simplemente te estoy enviando un mensaje".encode('ascii')
s.sendto(mensaje, (server_name, server_port))
data, direccion = s.recvfrom(MAXSIZE)#aquí opcionalmente podemos recibir información enviada de vuelta, ojo que recvfrom retorna
#además de los datos la dirección desde donde fueron enviados
print(data.decode('utf-8'))
```

**Servidor UDP:**

```
import socket
MAXSIZE = 2048
server_name = socket.gethostname()
server_port = 15000

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind(("",server_port))

while True:
    data, addr = s.recvfrom(MAXSIZE)
    respuesta = "Aquí va mi respuesta para {}".format(addr[0])
    s.sendto(respuesta.encode('utf-8'), addr)
```

----------


Extra
-------------

```
def abstractmethod(funcion):
    funcion.__isabstractmethod__ = True
    return funcion


class abstractproperty(property):
    __isabstractmethod__ = True


class ABCMeta(type):
    def __call__(cls, *args, **kw):
        absmethods = [
            attr for attr in dir(cls)
            if getattr(
                getattr(cls, attr),
                '__isabstractmethod__',
                False
            )
        ]
        
        if not absmethods:
            return super().__call__(*args, **kw)

        else:
            raise TypeError(
                "Can't instantiate abstract class {} "
                "with abstract methods {}".format(
                    cls.__name__,
                    ", ".join(absmethods)
                )
            )
```
```
issubclass(SubClase, Base)
isinstance(SubClase(), Base)
```

```
def parentesis_balanceados(string):
    """
    Verifica que solo tenga parentesis que se cierren.
    """
    count = 0
    for char in string:
        if char == '(':
            count += 1
        elif char == ')':
            count -= 1
        if count < 0:
            return False

    return count == 0


def test_parentesis_balanceados():
    input = "g(x) = ((2^x)+5*(42/f(x)))"
    assert parentesis_balanceados(input)


def test_parentesis_desbalanceados():
    input = "(2^(2^(2)) * 4"
    assert not parentesis_balanceados(input)


def test_sin_parentesis():
    input = "4+5"
    assert parentesis_balanceados(input)


def test_input_vacio():
    input = ""
    assert parentesis_balanceados(input)


def test_parentesis_mal_cerrados():
    input = "(2+4))((6%3)"
    assert not parentesis_balanceados(input)


"""
Ahora con unittest
"""
import unittest


class ParentesisTester(unittest.TestCase):

    def setUp(self):
        self.validos = [
            "g(x) = ((2^x)+5*(42/f(x)))",
            "4+5",
            ""
        ]

        self.invalidos = [
            "(2^(2^(2)) * 4",
            "(2+4))((6%3)"
        ]

    def test_validos(self):
        for ip in self.validos:
            self.assertTrue(parentesis_balanceados(ip))

    def test_invalidos(self):
        for ip in self.invalidos:
            self.assertFalse(parentesis_balanceados(ip))


suite = unittest.TestLoader().loadTestsFromTestCase(ParentesisTester)
unittest.TextTestRunner().run(suite)
```

```
from PyQt4 import QtGui, uic

# Cargamos la interfaz creada previamente
formulario = uic.loadUiType("qt-designer-radiobutton.ui")

# Creamos la clase que contendrá la interfaz
class MainWindow(formulario[0], formulario[1]):
    def __init__(self):
        super().__init__()
        
        # Inicializamos al interfaz
        self.setupUi(self)

        # Agregamos el slot al evento clicked del botón1
        self.pushButton1.clicked.connect(self.mostrar_gustos)

    # Este método controla el comportamiento del radiobutton
    def mostrar_gustos(self):
        
        for rb_id in range(1,3):
            if getattr(self, 'radioButton' + str(rb_id)).isChecked():
                opcion = getattr(self, 'radioButton' + str(rb_id)).text()
                self.label2.setText('prefiere: {0}'.format(opcion))
                self.label2.resize(self.label2.sizeHint())

if __name__ == '__main__':
    app = QtGui.QApplication([])
    form = MainWindow()
    form.show()
    app.exec_()
```

```
trigger = QtCore.pyqtSignal(MoveMyImageEvent)
self.trigger.connect(parent.actualizarImagen)
self.trigger.emit(MoveMyImageEvent(self.image, self.position[0], self.position[1]))
    def actualizarImagen(self, myImageEvent):
        label = myImageEvent.image
        label.move(myImageEvent.x, myImageEvent.y)
```

```
"{0:.8s}{1: ^9d}    ${2: <8.2f}${3: >7.2f}"
```

```
print(json.loads(json_string,parse_int=float))
datos = json.loads(json_string, object_hook = lambda dict_obj: [tuple((i,j)) for i,j in dict_obj.items()])
print(datos)
```

```
import socket
import threading
import sys


class Cliente:

    def __init__(self, usuario):
        self.usuario = usuario
        self.host = '127.0.0.1'
        self.port = 3491
        self.s_cliente = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connection = True
        try:
            # Un cliente se puede conectar solo a un servidor.
            self.s_cliente.connect((self.host, self.port)) # El cliente revisa que el servidor esté disponible
            # Una vez que se establece la conexión, se pueden recibir mensajes
            recibidor = threading.Thread(target=self.recibir_mensajes, args=())
            recibidor.daemon = True
            recibidor.start()
        except socket.error:
            print("No fue posible realizar la conexión")
            sys.exit()

    def recibir_mensajes(self):
        while self.connection:
            data = self.s_cliente.recv(1024)
            mensaje = data.decode('utf-8')
            if mensaje.split(': ')[1] == 'quit':
                self.desconectar()
                print('El servidor se ha desconectado')
                print(self.connection)
            print(mensaje)

    def enviar(self, mensaje):
        msj_final = self.usuario + ": " + mensaje
        self.s_cliente.send(msj_final.encode('utf-8'))

    def desconectar(self):
        self.connection = False
        self.s_cliente.close()


class Servidor:

    def __init__(self, usuario, num_clients=1):
        self.usuario = usuario
        self.host = '127.0.0.1'
        self.port = 3491
        self.s_servidor = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # Debemos hacer el setup para poder escuchar a los clientes que se quieran conectar
        self.s_servidor.bind((self.host, self.port))
        # En este caso solo queremos escuchar un cliente
        self.s_servidor.listen(num_clients)
        self.clientes = []
        self.connection = True

        # No hacemos self.aceptar()

        thread_aceptar = threading.Thread(target=self.aceptar, args=())
        thread_aceptar.daemon = True
        thread_aceptar.start()

    def recibir_mensajes(self, cliente):
        while self.connection:
            data = cliente.recv(1024)
            mensaje = data.decode('utf-8')
            if mensaje.split(': ')[1] == 'quit':
                self.clientes.remove(cliente)
            print(mensaje)

    def aceptar(self):
        while True:
            cliente_nuevo, address = self.s_servidor.accept()
            self.clientes.append(cliente_nuevo)
            thread_mensajes = threading.Thread(target=self.recibir_mensajes, args=(cliente_nuevo,))
            thread_mensajes.daemon = True
            thread_mensajes.start()

    def enviar(self, mensaje):
        c, mensaje = mensaje.split(',')
        msj_final = self.usuario + ": " + mensaje
        self.clientes[int(c)].send(msj_final.encode('utf-8'))

    def desconectar(self):
        for i in range(len(self.clientes)):
            self.enviar(str(i) + ',quit')
        self.connection = False
        self.s_servidor.close()



if __name__ == "__main__":

    pick = input("Ingrese S si quiere ser servidor o C si desea ser cliente: ")
    if pick == "S":
        nombre = input("Ingrese el nombre del usuario: ")
        server = Servidor(nombre, num_clients=2)
        while server.connection:
            texto = input()
            if texto == 'quit':
                server.desconectar()
            else:
                server.enviar(texto)
    else:
        nombre = input("Ingrese el nombre del usuario: ")
        client = Cliente(nombre)
        while client.connection:
            texto = input()
            if texto == 'quit':
                client.enviar('quit')
                client.desconectar()
            else:
                client.enviar(texto)
```

Ventajas
Los archivos JSON pueden ser leídos por múltiples lenguajes, en cambio los archivos creados con pickle solo pueden ser leídos por programas en python.
Es más rápido que pickle
Son entendibles por humanos
Desventajas
JSON no serializa funciones o clases


Un context manager es un objeto que define el contexto de ejecución que se establece cuando se ejecuta un with. Este se preocupa de ejecutar los métodos __enter__ y __exit__ cuando corresponda.
__enter__: define lo que el context manager debe hacer al inicio del bloque creado por with. Lo que retorna está restringido por el target del with.
__exit__: define lo que el context manager debe hacer después de que el bloque creado por with haya terminado de ejecutarse o que haya lanzado un error.


Una clase abstracta es una clase que no puede instanciarse. Ventajas:
Establecen un comportamiento para todas las clases que heredan de ella.
Obligan a que las clases que heredan de ella implementen los métodos abstractos.


La simulación es síncrona. Es una cola con una caja, por lo que no es posible paralelizar su ejecución.